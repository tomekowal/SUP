-module(sup_server_management).
-include("sup_beagle.hrl").
-include("db/sup_db.hrl").
-export([start_link/0, loop/1, begin_session/1]).
-define(TCP_TIMEOUT, 30000).

-record(session_data,
        {identity :: nonempty_string(),
         start_time :: {term(), term()},
         reason :: term(),
         failed_jobs :: integer()
        }).

%%------------------------------------------------------------------------------
%% @doc Starts the management server (network server listening on port).
%% @end
%%------------------------------------------------------------------------------
start_link() ->
    Options = [binary, {packet, 4}, {active, false}],
    {ok, ServerSocket} = gen_tcp:listen(5678, Options),
    {ok, spawn_link(?MODULE, loop, [ServerSocket])}.

%%------------------------------------------------------------------------------
%% Management server main loop.
%%
%% Listens for connections and spawns a session process for each one.
%%------------------------------------------------------------------------------
loop(ServerSocket) ->
    {ok, Socket} = gen_tcp:accept(ServerSocket),
    spawn(?MODULE, begin_session, [Socket]),
    ?MODULE:loop(ServerSocket).

%%------------------------------------------------------------------------------
%% Begins session with the client.
%%
%% It receives initial message from the client, passes it to {@link
%% init_session} which returns session data and initial list of jobs to pass to
%% the client. Then, main session loop is invoked which sends jobs to the
%% client, receives their results and passes them to their appropriate handlers.
%% -----------------------------------------------------------------------------
begin_session(Socket) ->
    try
        {ok, Packet} = gen_tcp:recv(Socket, 0, ?TCP_TIMEOUT),
        SessionData = init_session(Socket, binary_to_term(Packet)),
        session_loop(Socket, SessionData)
    catch
        Exception ->
            io:format("Session failed: ~p~n", [Exception])
    end,
    ok.

%%------------------------------------------------------------------------------
%% Main session loop.
%%
%% session_loop(Socket, SessionData, Handlers) -> finished | broken.
%%   Socket = socket()
%%   SessionData = term()
%%   Handlers = [{Job, Module, Function, Extra}]
%%   Job = term()
%%   Module = atom()
%%   Function = fun(Job, Message, SessionData, Extra) -> Handlers
%%   Extra = Message = term()
%%
%% Socket is the socket for TCP connection associated with this session.
%% SessionData is an immutable term initialized by {@link init_session} and
%% passed to each handler function.
%%
%% Job is the job that will be sent to the client.
%%
%% Module and Function specify handler function that will be called after
%% receiving job result from the client. Each handler function returns a list of
%% its subhandlers which will be inserted at the beginnig of handler list passed
%% to the next session_loop invocation. This way each handler function can spawn
%% its subhandlers based on the result of the job.
%%
%% Message is the job result received from the client.
%%
%% Extra is extra data that will be passed to the handler function.
%%
%% Loop arguments are the Socket, SessionData and a list of jobs with their
%% handlers. SessionData is generated by {@link init_session} and cannot be
%% changed. Each job in the list is a tuple {Job, Module, Function, Extra}.
%%
%% -----------------------------------------------------------------------------
session_loop(Socket, SessionData) ->
    Identity = SessionData#session_data.identity,
    FailedJobs = SessionData#session_data.failed_jobs,
    case sup_db:fetch_job(Identity, FailedJobs+1) of
        {ok, {job, Message, Module, Function, Extra, _Status}} ->
            io:format("JOB to send: ~p~n", [Message]),
            try
                ok = gen_tcp:send(Socket, term_to_binary(Message)),
                {ok, Packet} = gen_tcp:recv(Socket, 0, ?TCP_TIMEOUT),
                try
                    Result = binary_to_term(Packet),
                    HandlerArgs = [Message, Result, SessionData, Extra],
                    case apply(Module, Function, HandlerArgs) of
                        {next_job, NextJob} ->
                            sup_db:replace_job(Identity, FailedJobs+1, NextJob);
                        none ->
                            sup_db:delete_job(Identity, FailedJobs+1)
                    end,
                    session_loop(Socket, SessionData)
                catch
                    _:HandlerException ->
                        sup_db:fail_job(Identity, FailedJobs+1, HandlerException),
                        NewSessionData = SessionData#session_data{failed_jobs = FailedJobs+1},
                        session_loop(Socket, NewSessionData)
                end
            catch
                %% connection broken, fail entire session
                _:NetException ->
                    sup_db:fail_job(Identity, FailedJobs+1, NetException)
            end;
        empty ->
            ok = gen_tcp:send(Socket, term_to_binary(finished)),
            ok = gen_tcp:close(Socket),
            ok
    end.

%% -----------------------------------------------------------------------------
%% Initializes session data and initial handler list to be executed in the newly
%% begun session.
%%
%% init_session(Message :: term()) -> {SessionData :: term(), Handlers}.
%%
%% {@see session_loop}
%% -----------------------------------------------------------------------------
init_session(Socket, Message) ->
    %% that is just a stub, this must be actually implemented
    %io:format("Message from device: ~p~n", [Message]),
    Fun = fun() ->
        case mnesia:read(device, Message#inform.identity, write) of
            [Device] ->
                Device;
            [] ->
                Device = init_device(Socket, Message),
                mnesia:write(Device),
                Device
        end
    end,
    {atomic, _Device} = mnesia:transaction(Fun),
    #session_data{
            identity = Message#inform.identity,
            start_time = calendar:universal_time(),
            reason = Message#inform.reason,
            failed_jobs = 0
           }.

init_device(Socket, Message) ->
    {ok, {Address, _Port}} = inet:peername(Socket),
    Releases = lists:map(
                 fun(Rel) -> sup_server_utils:make_release_record(Rel) end,
                 Message#inform.releases),
    #device{
             identity = Message#inform.identity,
             last_contact = calendar:universal_time(),
             releases = Releases,
             ip = sup_server_utils:ip4addr_to_list(Address),
             jobs = []
           }.


