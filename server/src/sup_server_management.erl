-module(sup_server_management).
-export([start_link/0, loop/1, begin_session/1]).

%%------------------------------------------------------------------------------
%% @doc Starts the management server (network server listening on port).
%% @end
%%------------------------------------------------------------------------------
start_link() ->
    Options = [binary, {packet, 4}, {active, false}],
    {ok, ServerSocket} = gen_tcp:listen(5678, Options),
    {ok, spawn_link(?MODULE, loop, [ServerSocket])}.

%%------------------------------------------------------------------------------
%% Management server main loop.
%%
%% Listens for connections and spawns a session process for each one.
%%------------------------------------------------------------------------------
loop(ServerSocket) ->
    {ok, Socket} = gen_tcp:accept(ServerSocket),
    spawn(?MODULE, begin_session, [Socket]),
    ?MODULE:loop(ServerSocket).

%%------------------------------------------------------------------------------
%% Begins session with the client.
%%
%% It receives initial message from the client, passes it to {@link
%% init_session} which returns session data and initial list of jobs to pass to
%% the client. Then, main session loop is invoked which sends jobs to the
%% client, receives their results and passes them to their appropriate handlers.
%% -----------------------------------------------------------------------------
begin_session(Socket) ->
    try
        {ok,Packet} = gen_tcp:recv(Socket,0),
        {SessionData, Handlers} = init_session(binary_to_term(Packet)),
        session_loop(Socket, SessionData, Handlers)
    catch
        Exception ->
            io:format("Session failed: ~p~n", [Exception])
    end,
    ok.

%%------------------------------------------------------------------------------
%% Main session loop.
%%
%% session_loop(Socket, SessionData, Handlers) -> finished | broken.
%%   Socket = socket()
%%   SessionData = term()
%%   Handlers = [{Job, Module, Function, Extra}]
%%   Job = term()
%%   Module = atom()
%%   Function = fun(Job, Message, SessionData, Extra) -> Handlers
%%   Extra = Message = term()
%%
%% Socket is the socket for TCP connection associated with this session.
%% SessionData is an immutable term initialized by {@link init_session} and
%% passed to each handler function.
%%
%% Job is the job that will be sent to the client.
%%
%% Module and Function specify handler function that will be called after
%% receiving job result from the client. Each handler function returns a list of
%% its subhandlers which will be inserted at the beginnig of handler list passed
%% to the next session_loop invocation. This way each handler function can spawn
%% its subhandlers based on the result of the job.
%%
%% Message is the job result received from the client.
%%
%% Extra is extra data that will be passed to the handler function.
%%
%% Loop arguments are the Socket, SessionData and a list of jobs with their
%% handlers. SessionData is generated by {@link init_session} and cannot be
%% changed. Each job in the list is a tuple {Job, Module, Function, Extra}.
%%
%% -----------------------------------------------------------------------------
session_loop(Socket, _SessionData, []) ->
    ok = gen_tcp:send(Socket, term_to_binary(finished)),
    ok = gen_tcp:close(Socket),
    ok;
session_loop(Socket, SessionData, [Handler | PendingHandlers]) ->
    {Job, Module, Function, Extra} = Handler,
    ok = gen_tcp:send(Socket, term_to_binary(Job)),
    {ok, Packet} = gen_tcp:recv(Socket, 0),
    Message = binary_to_term(Packet),
    HandlerArgs = [Job, Message, SessionData, Extra],
    MoreHandlers = apply(Module, Function, HandlerArgs),
    session_loop(Socket, SessionData, MoreHandlers++PendingHandlers).

%% -----------------------------------------------------------------------------
%% Initializes session data and initial handler list to be executed in the newly
%% begun session.
%%
%% init_session(Message :: term()) -> {SessionData :: term(), Handlers}.
%%
%% {@see session_loop}
%% -----------------------------------------------------------------------------
init_session(Message) ->
    %% that is just a stub, this must be actually implemented
    io:format("Releases present on client: ~n~p~n", [Message]),
    [{identity,Identity} | [{reason,Reason} | _Rest]] = Message,
    SessionData = [{identity, Identity}],
    case Reason of
        upgrade_request ->
            Handlers = [{{get_release, "beagle_2.0"}, sup_server_handlers, upgrade_handler, ignore}];
        periodic_notify ->
            Handlers = [{sample_job, sup_server_handlers, print_result_handler, ignore}];
        _ ->
            Handlers = []
    end,
    {SessionData, Handlers}.
